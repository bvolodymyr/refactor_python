Крок 1: Ознайомлення з кодом
Код, що наведений, є реалізацією системи підрахунку очок у тенісному матчі з використанням трьох різних версій класу TennisGame.

Основні компоненти:
Класи:

TennisGameDefactored1: Реалізує логіку підрахунку очок у тенісі з більш складним обробленням очок і умов.
TennisGameDefactored2: Додає окремі методи для збільшення очок, детальніше форматування результатів і перевірки таких умов, як "Перевага" та "Перемога".
TennisGameDefactored3: Спрощує реалізацію, використовуючи масиви для назв очок і перевіряючи умови за допомогою базової арифметики та конкатенації рядків.
Методи:

won_point(self, playerName): Збільшує очки гравця залежно від введеного імені.
score(self): Повертає поточний рахунок у вигляді рядка залежно від поточного стану гри.
У TennisGameDefactored2 методи, такі як P1Score та P2Score, використовуються для інкапсуляції логіки підрахунку очок.
Обчислення рахунку: Рахунок обчислюється різними способами в різних версіях. Основні моменти:

Обробка випадку, коли рахунок у двох гравців однаковий (Love-All, Fifteen-All тощо).
Виявлення, коли гравець виграв або має перевагу.
Повернення рахунку у зручному для людини форматі, як-от "Love", "Fifteen" тощо.
Розуміння логіки:
Кожна версія класу TennisGame слідує основним правилам підрахунку очок у тенісі, але має різний підхід до їх реалізації.

Крок 2: Статичний аналіз коду
Для статичного аналізу коду можна використовувати інструмент, спеціалізований для Python, наприклад, Pylint або PyFlakes. Ці інструменти допомагають виявити типові проблеми в коді, такі як синтаксичні помилки, невикористовувані змінні, дублювання коду та складність.

Крок 3: Виявлення основних проблем
Після ручного перегляду коду можна виявити кілька проблем:

1. Дублювання коду
Усі три класи мають схожу логіку для перетворення очок з чисел на назви, такі як "Love", "Fifteen", "Thirty". Ця логіка повторюється в кількох місцях.
Приклад: у TennisGameDefactored1 та TennisGameDefactored2 назви очок (наприклад, "Love", "Fifteen") хардкодяться в кількох місцях. Це збільшує ймовірність помилок при майбутніх змінах.
2. Складність коду
Метод score у TennisGameDefactored2 є досить складним і довгим. Він має багато умов, які можна спростити.
Цей метод можна рефакторити, використовуючи словники або мапи для обробки переходів рахунків, що зменшить кількість умовних операторів.
3. Неконсистентність в назвах
У класі TennisGameDefactored2 є неконсистентні назви методів (SetP1Score, SetP2Score, P1Score, P2Score). Ці назви можуть бути більш інтуїтивно зрозумілими і консистентними.
4. Хардкодинг значень
У TennisGameDefactored2 значення типу "Fifteen", "Thirty", "Forty" повторюються в коді. Це можна покращити, визначивши їх у списку або константах.
5. Відсутність тестів
Хоча метод score() є центральним для функціональності, не надано юніт-тестів для перевірки його коректності. Без тестів складніше гарантувати правильність функціонування при зміні чи розширенні коду.
Крок 4: Наслідки виявлених проблем
1. Дублювання коду:
Вплив на читабельність: Дублювання коду ускладнює його підтримку та розуміння. Зміна в одному місці може потребувати змін в кількох інших місцях, що збільшує ймовірність помилок.
Вплив на підтримуваність: Якщо система підрахунку очок зміниться, треба буде оновити кожен блок дубльованого коду, що займає багато часу і може призвести до помилок.
2. Складність коду:
Вплив на читабельність: Чим складніший код, тим важче його читати та розуміти, особливо для нового розробника.
Вплив на підтримуваність: Складна логіка сприяє виникненню помилок під час змін. Розробникам буде складніше вносити зміни, не порушивши існуючий функціонал.
3. Неконсистентність в назвах:
Вплив на читабельність: Неконсистентні назви знижують зрозумілість коду. Це може заплутати інших розробників, які працюють із кодом, або навіть самого автора через деякий час.
Вплив на підтримуваність: Неконсистентні назви можуть призвести до помилок, і передбачити, що робить метод, без перевірки його реалізації, буде важче.
4. Хардкодинг значень:
Вплив на підтримуваність: Хардкодинг значень, таких як "Fifteen" і "Thirty", ускладнює їх зміну. Якщо їх потрібно змінити, доведеться знайти кожне місце в коді, де вони використані, і змінити вручну.
Вплив на читабельність: Ці значення не дають чіткого розуміння контексту, що ускладнює розуміння намірів розробника.
5. Відсутність тестів:
Вплив на надійність: Без тестів важко гарантувати, що логіка підрахунку очок працює правильно в усіх ситуаціях. Тести допомогли б перевірити різні сценарії гри.
Рекомендації для покращення:
Рефакторинг спільної логіки: Варто винести загальну логіку в окремі методи чи класи, щоб зменшити дублювання коду. Наприклад, назви очок можна зберігати в словнику, і використовувати допоміжну функцію для отримання відповідного значення.

Спрощення складних методів: Розділіть метод score на менші, більш керовані методи. Це покращить читабельність і зменшить складність розуміння коду.

Покращення консистентності в назвах: Використовуйте консистентні та зрозумілі назви для методів і змінних, що зробить код легшим для сприйняття.

Використання констант або Enum для назв очок: Замість хардкодингу значень типу "Fifteen", "Thirty" можна використовувати константи або перерахування, що покращить підтримуваність і знизить ймовірність помилок.

Додавання юніт-тестів: Реалізуйте юніт-тести для методу score(), щоб перевірити його правильність. Використовуйте фреймворки, такі як unittest або pytest, для валідації різних сценаріїв гри.

Використання інструментів статичного аналізу коду: Для виявлення потенційних проблем на ранніх етапах інтегруйте інструмент статичного аналізу, такий як Pylint, у процес розробки.
